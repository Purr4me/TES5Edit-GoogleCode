Thanks for responding after downloading the EXE I posted.  I'd like to use some of your feedback to illustrate the fact that I think most people think this project requires making something from scratch to do a really big job.  I think people that might be able to help don't try because it looks really daunting.  For the most part if you understand programming in any language you can figure out the source code  with some effort.  If more people downloaded the source, the Trial of Delphi, and compiled the source code at least once, it would make a big difference.  

I'm not challenging your statements or your feedback.  They are valid and fair.  So I apologize in advance and respect you and your feedback but maybe you and others will understand a bit more about the project, and the capabilities of xDump after I comment on this.

For anyone reading this.  If you haven't already done so, you can look at xDump's source code, and compile it with the trial version of Delphi XE2 as mentioned in the first post.  You don't have to volunteer to help with the project either.  I'm just saying seeing is believing and trying Delphi and compiling the source will cost you nothing but some time.

[quote name='SLuckyD' timestamp='1342028370' post='21190788']
Shorts in Snip cannot be signed unless specifically defined, if just "short" then it is unsigned (won't allow saving negative values).  And yea, the short is always 2bytes (02 00); "int" is always 4bytes (what you'd probably call intU32 or intS32), as are floats.[/quote]I can see that.  That might help define things a bit in the source code.  I'll keep that in mind when comparing your notes, and what Snip has defined.

[quote name='SLuckyD' timestamp='1342028370' post='21190788']
As for Dump, it's pretty nice.  Very fast.  It's definitely a great start...[/quote]It's not a start, it's a complete tool that's just misunderstood.  The program is in its fourth iteration, it has the capabilities to decode FO3, FNV, and TES4.  Both TES5Dump and TES5Edit work the same way.  If you rename the file you downloaded from the project site it will function for that specific game mode.  For Example: Rename TES5Dump-SVN78.exe to FNVDump.exe, FO3Dump.exe, or TES4Dump.exe.  It already has the proper definitions in place for those games and the output will seem more complete.  Try it on a plugin for one of those games the same way you are doing for Skyrim.

I really did not check to see if I renamed TES5Dump to TES5Dump-SVN78.exe whether or not it would still run in the game mode for Skyrim or not.  If you did rename it to just TES5Dump.exe it would still work the same as it does now because the wbDefinitionsTES5.pas needs to be updated, and then the entire source code needs to be compiled again to see the changes.  Which is what we are doing for this project.

Note: I suggest using the -dg: switch on oblivion files.
TES4Dump.exe -dg:WTHR "Your Plugin.esp" > "Your Plugin.txt"

[quote name='SLuckyD' timestamp='1342028370' post='21190788']
- especially since it's a text file which can be compared/viewed/scanned and easily shared without cut-paste.[/quote]That is sweet isn't it!

[quote name='SLuckyD' timestamp='1342028370' post='21190788']
I recommend outputting each record and subrecord's stamped size (the short/int after the actual record/subrecord 4byte name, eg- FULL, NPC_, etc)... this way one can compare if there is any corruption or inconsistencies.[/quote]What the program does by default is tell you when there is unused data as it scans an esp/esm file.  Also the routines can be set to "wbUnknown(QNAM)" and that will show only hex values.  You can verify the data that way and then use a pre defined pascal function to format it correctly.

[quote name='SLuckyD' timestamp='1342028370' post='21190788']
"unknon data" misspelled[/quote]LOL!  I'll fix that.

[quote name='SLuckyD' timestamp='1342028370' post='21190788']
I know this kinda stuff is expected this early in the development; but in general, there are a bunch of errors that come up, and a lot of missing or incomplete data.  Such as:

[spoiler][code]
- in the HEDR
"2 unknown" is the size of record (as I mention above)

- NAVM dumps return a bunch of errors because NVNM subrecords aren't recognized (all NAVMs always have one)

- NVMI subrecord doesn't return anything, and NAVI only returns super-basic general info about the GRUP

- in the WTHR record
MNAM - missing all data x2
RNAM - missing all data
QNAM - missing all data
JNAM - missing all data
FNAM - missing day/night max (cuts off the end of the subrecord)
IMSP - missing all data (is formIDs of IMGSs)
DALC - missing all data
[/code][/spoiler][/quote]
This will become my new Wiki entry :D

Also it's important to reiterate what is mentioned in the first post.  The wbDefinitionsTES5.pas is but one of about 80 files used to make TES5Edit and it's predecessors FO3Edit, FNVEdit, and TES4Edit.  Which as mentioned are the same file just renamed.  The complexity of the object oriented programing involved makes it so that once we are done with wbDefinitionsTES5.pas the pascal file is used to make TES5Edit.  Granted some other things will need to be updated in the supporting files but I am doing work on additional files to save Elminster some time, and help get us a working copy of TES5Edit.  Updates to TES5Edit will apply to previous versions automatically.

Ok now I'm gonna bust out the colors and I'll outline some steps to resolve what you mentioned.  These steps are the most basic examples.  There is more to it then this but it should give you and anyone else reading this how Delphi is used to make this tool dump the data correctly thus leading to TES5Edit.

[code]MNAM - missing all data x2[/code]
I assume this is dumped as 
[code]MNAM
MNAM[/code]

In which you use one of the array functions to deal with both.  Other records could contain 2 or more of "MNAM" and the array function will capture all that exist.

To start with you need to find the record you are working with.  So since this is weather you would use "wbRecords(WTHR" and that will take you to this record.  In it's current state like many of the records its simply a copy of FNV information for now.

You also need to open the USEPWiki to refer to if some of the records follow a pattern, such as this in this example of the NPC_ record.  These are listed in this exact order several times.
[code]    wbRArray('Unknown - TINI, TINC, TINV, TIAS', wbRStruct('Unknown', [
      wbUnknown(TINI),
      wbUnknown(TINC),
      wbUnknown(TINV),
      wbUnknown(TIAS)
    ], []))
  ], True, nil, cpNormal, False, wbNPCAfterLoad);
[/code]

Here is how WTHR was when I started writing this example.
[spoiler][code]
// From the top of the file
  _0_IAD : TwbSignature = #0'IAD';
  _1_IAD : TwbSignature = #1'IAD';
  _2_IAD : TwbSignature = #2'IAD';
  _3_IAD : TwbSignature = #3'IAD';
  _4_IAD : TwbSignature = #4'IAD';
  _5_IAD : TwbSignature = #5'IAD';

// and then the routine itself.

  wbRecord(WTHR, 'Weather', [
    wbEDIDReq,
    wbFormIDCk(_0_IAD, 'Sunrise Image Space Modifier', [IMAD]),
    wbFormIDCk(_1_IAD, 'Day Image Space Modifier', [IMAD]),
    wbFormIDCk(_2_IAD, 'Sunset Image Space Modifier', [IMAD]),
    wbFormIDCk(_3_IAD, 'Night Image Space Modifier', [IMAD]),
    wbFormIDCk(_4_IAD, 'Unknown', [IMAD]),
    wbFormIDCk(_5_IAD, 'Unknown', [IMAD]),
    wbString(DNAM, 'Cloud Textures - Layer 0', 0, cpNormal, True),
    wbString(CNAM, 'Cloud Textures - Layer 1', 0, cpNormal, True),
    wbString(ANAM, 'Cloud Textures - Layer 2', 0, cpNormal, True),
    wbString(BNAM, 'Cloud Textures - Layer 3', 0, cpNormal, True),
    wbMODL,
    wbByteArray(LNAM, 'Unknown', 4, cpNormal, True),
    wbArray(ONAM, 'Cloud Speed', wbInteger('Layer', itU8{, wbDiv(2550)}), 4, nil, nil, cpNormal, True),
    wbByteArray(PNAM, 'Unused', 0, cpIgnore),
    wbArray(NAM0, 'Colors by Types/Times',
      wbArray('Type',
        wbStruct('Time', [
          wbInteger('Red', itU8),
          wbInteger('Green', itU8),
          wbInteger('Blue', itU8),
          wbByteArray('Unused', 1)
        ]),
        ['Sunrise', 'Day', 'Sunset', 'Night', 'High Noon', 'Midnight']
      ),
      ['Sky-Upper','Fog','Clouds-Lower','Ambient','Sunlight','Sun','Stars','Sky-Lower','Horizon','Clouds-Upper']
    , cpNormal, True),
    wbStruct(FNAM, 'Fog Distance', [
      wbFloat('Day - Near'),
      wbFloat('Day - Far'),
      wbFloat('Night - Near'),
      wbFloat('Night - Far'),
      wbFloat('Day - Power'),
      wbFloat('Night - Fower')
    ], cpNormal, True),
    wbByteArray(INAM, 'Unused', 304, cpIgnore, True),
    wbStruct(DATA, '', [
      wbInteger('Wind Speed', itU8),
      wbInteger('Cloud Speed (Lower)', itU8),
      wbInteger('Cloud Speed (Upper)', itU8),
      wbInteger('Trans Delta', itU8),
      wbInteger('Sun Glare', itU8),
      wbInteger('Sun Damage', itU8),
      wbInteger('Precipitation - Begin Fade In', itU8),
      wbInteger('Precipitation - End Fade Out', itU8),
      wbInteger('Thunder/Lightning - Begin Fade In', itU8),
      wbInteger('Thunder/Lightning - End Fade Out', itU8),
      wbInteger('Thunder/Lightning - Frequency', itU8),
      wbInteger('Weather Classification', itU8, wbWthrDataClassification),
      wbStruct('Lightning Color', [
        wbInteger('Red', itU8),
        wbInteger('Green', itU8),
        wbInteger('Blue', itU8)
      ])
    ], cpNormal, True),
    wbRArray('Sounds', wbStruct(SNAM, 'Sound', [
      wbFormIDCk('Sound', [SOUN]),
      wbInteger('Type', itU32, wbEnum([
       {0}'Default',
       {1}'Precip',
       {2}'Wind',
       {3}'Thunder'
      ]))
    ]))
  ]);
[/code][/spoiler]

I can't post the WTHR Record TES5Dump made because it's insane how much information is in even one of them.  Which is why I'm not working on it yet because there are smaller records that could be defined easier and then used in Wrye Bash.

[spoiler][code]    00TX
    10TX
    20TX
    30TX
    <0TX
    =0TX
    >0TX
    ?0TX
    C0TX
    D0TX
    L0TX
[/code][/spoiler] I don't know how those are handled yet I'm gonna skip those.

but after LNAM we have MNAM, NNAM, RNAM, and QNAM.  Those MUST come after LNAM.  Any one of those could be a FromID but I'm going to use wbUnknown as just an example for now.  I'll use another command for unknown FormIds below.  
[code]
*snip*
    wbByteArray(LNAM, 'Unknown', 4, cpNormal, True),
    wbUnknown(MNAM),
    wbUnknown(NNAM),
    wbUnknown(RNAM),
    wbUnknown(QNAM),
    wbArray(ONAM, 'Cloud Speed', wbInteger('Layer', itU8{, wbDiv(2550)}), 4, nil, nil, cpNormal, True),
*snip*
[/code]

After PNAM there is a JNAM
Before SNAM is NAM1
There are a bunch of TNAM after SNAM which the wiki says are FormIDs.  If you didn't know that use wbUnknown(TNAM) however, I'm going to use "    wbFormID(TNAM, 'Unknown')," inside a Record Array function[code]
    wbRArray('Unknown - TNAM', wbRStruct('Unknown', [
      wbFormID(TNAM, 'Unknown')
    ], []))[/code]
	
After all the TNAM entries are some more things that need to be defined:[code]    IMSP
    DALC
    DALC
    DALC
    DALC
    MODL
    MODT[/code] 

So something like this.	
[code]    wbRArray('Unknown - TNAM', wbRStruct('Unknown', [
      wbFormID(TNAM, 'Unknown')
    ], [])),
    wbUnknown(IMSP),
    wbRArray('Unknown - DALC', wbRStruct('Unknown', [
      wbFormID(DALC, 'Unknown')
    ], [])),
    wbUnknown(MODL),
    wbUnknown(MODT)
  ]);
[/code]
[code]
  IMSP
  DALC
	
  IMSP : TwbSignature = 'IMSP'; { New to Skyrim }
  DALC : TwbSignature = 'DALC'; { New to Skyrim }[/code]
Those are new so they need to be entered as a constant at the top of the file.  Also add them in alphabetical order and with a comment that they are new. :D  

After all that and you re compile it, then xDump will give you different results.  Once you rinse and repeat, the record is defined and a decoder makes a ticket for the wiki team (Or just does it themselves) and then the USEPWiki has valid information for the cumunity to refer to.


[code]wbString(BNAM, 'Cloud Textures - Layer 3', 0, cpNormal, True),
wbMODL,[/code]
Now, with all that said though these are FNV structures and wbMODL could be in the wrong place.  To start decoding WTHR properly it's best to comment out ALL of the code.  Look at the order of things and then uncomment everything to fit that order.  Changing the order when needed.

[quote name='SLuckyD' timestamp='1342028370' post='21190788']
Thanks for working on this app, and I look forward to using it more!  I downloaded the .pas file for the definitions, but it's too foreign for me to jump right into editing - if I get some extra time in the next couple weeks I may be able to learn enough to get by.
[/quote]That is perfectly ok.  I'm glad you got the files, and as mentioned it compiles with a trial version.  With enough people working on it the 30 days would be enough time.  I just need more volunteers to help.